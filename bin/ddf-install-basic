#!/bin/bash

verbose_message() {
   if [ -z $2 ]; then 
      message_verbosity=1
   else
      message_verbosity=$2
   fi
   if [[ "$VERBOSE" -ge "$message_verbosity" ]]; then
      echo $1
   fi
}



random_string() {
   echo `tr -dc a-zA-Z < /dev/urandom  | head -c 10`
}

export_to_shells() {
   verbose_message "exporting $1"
   shell_files=(bashrc zshrc cshrc profile)
   for shell_file in ${shell_files[*]}; do
      verbose_message "export $1=$2 to ~/.$shell_file" 2
      echo "export $1=$2" >> ~/.$shell_file
   done
}

# Get current directory
SOURCE="${BASH_SOURCE[0]}"
while [ -h "$SOURCE" ]; do # resolve $SOURCE until the file is no longer a symlink
  DIR="$( cd -P "$( dirname "$SOURCE" )" >/dev/null 2>&1 && pwd )"
  SOURCE="$(readlink "$SOURCE")"
  [[ $SOURCE != /* ]] && SOURCE="$DIR/$SOURCE" # if $SOURCE was a relative symlink, we need to resolve it relative to the path where the symlink file was located
done
DIR="$( cd -P "$( dirname $( dirname "$SOURCE") )" >/dev/null 2>&1 && pwd )"

source $DIR/settings

verbose_message "SLAVE INSTALL: $SLAVE_INSTALL"
verbose_message "VERBOSITY: $VERBOSE"

# Set some basic variables
DISTRO_ID=`cat /etc/*-release | awk -F '=' '/^ID/ {print $2}'`
verbose_message "DISTRO_ID: $DISTRO_ID"

verbose_message ""
verbose_message "Exporting envs: "
export_to_shells DDF_DIR $DIR
export_to_shells DDF_BIN $DIR/bin

export_to_shells PATH "$DIR/own-bin/private:$DIR/own-bin/hosts:$DIR/bin:\$PATH"


verbose_message ""
verbose_message "Preparing packages: "
# Install basic packages (multisystem)
if [[ "$DISTRO_ID" == 'arch' ]]; then
   verbose_message "sudo pacman -Sy --noconfirm git python ansible"
   pacman -Sy --noconfirm git python ansible
fi
